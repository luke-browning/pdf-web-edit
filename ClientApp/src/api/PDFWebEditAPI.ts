//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export module PDFWebEditAPI {
export const BASE_URL = new InjectionToken<string>('BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ConfigurationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the configuration.
     * @return The configuration.
     */
    getConfiguration(): Observable<Config | null> {
        let url_ = this.baseUrl + "/api/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Config | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Config | null>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<Config | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Config.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Saves a configuration.
     * @param config The configuration.
     * @return The updated config
     */
    saveConfiguration(config: Config): Observable<Config | null> {
        let url_ = this.baseUrl + "/api/configuration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Config | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Config | null>;
        }));
    }

    protected processSaveConfiguration(response: HttpResponseBase): Observable<Config | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Config.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Reload configuration.
     * @return A status code indicating success or failure.
     */
    reloadConfiguration(): Observable<Config | null> {
        let url_ = this.baseUrl + "/api/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReloadConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReloadConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Config | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Config | null>;
        }));
    }

    protected processReloadConfiguration(response: HttpResponseBase): Observable<Config | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Config.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DocumentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the directories in this collection.
     * @return An enumerator that allows foreach to be used to process the directories in this collection.
     */
    getDirectories(): Observable<Folder | null> {
        let url_ = this.baseUrl + "/api/documents/directories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDirectories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDirectories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Folder | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Folder | null>;
        }));
    }

    protected processGetDirectories(response: HttpResponseBase): Observable<Folder | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Folder.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a directory.
     * @param targetDirectory The target directory.
     * @param name The name.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return The new directory.
     */
    createDirectory(targetDirectory: TargetDirectory, name: string, subDirectory?: string | null | undefined): Observable<Folder | null> {
        let url_ = this.baseUrl + "/api/documents/directories?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined and cannot be null.");
        else
            url_ += "targetDirectory=" + encodeURIComponent("" + targetDirectory) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDirectory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDirectory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Folder | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Folder | null>;
        }));
    }

    protected processCreateDirectory(response: HttpResponseBase): Observable<Folder | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Folder.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the documents in the selected folder.
     * @param targetDirectory The target directory.
     * @return An enumerator that allows foreach to be used to process the documents in this collection.
     */
    getDocuments(targetDirectory: TargetDirectory): Observable<Document[] | null> {
        let url_ = this.baseUrl + "/api/documents/list/{targetDirectory}";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document[] | null>;
        }));
    }

    protected processGetDocuments(response: HttpResponseBase): Observable<Document[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Document.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return The document.
     */
    getDocument(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/list/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processGetDocument(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return The document.
     */
    downloadDocument(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/documents/download/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDownloadDocument(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Posts a document.
     * @param model (optional) Form Data with the document as "file=".
     * @return The document.
     */
    uploadDocument(model?: FileUploadModel | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/documents/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (model === null || model === undefined)
            throw new Error("The parameter 'model' cannot be null.");
        else
            content_.append("model", JSON.stringify(model));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadDocument(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets page count of the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return The page count.
     */
    getPageCount(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/documents/page-count/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetPageCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets page preview in the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pageNumber The page number (starting at 1).
     * @param width The page width.
     * @param height The page height.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return The page preview.
     */
    getPagePreview(targetDirectory: TargetDirectory, document: string, pageNumber: number, width: number, height: number, subDirectory?: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/documents/preview/{targetDirectory}/{document}/{pageNumber}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (width === undefined || width === null)
            throw new Error("The parameter 'width' must be defined and cannot be null.");
        else
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height === undefined || height === null)
            throw new Error("The parameter 'height' must be defined and cannot be null.");
        else
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagePreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagePreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetPagePreview(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Renames a document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param newDocumentName New name of the document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    rename(targetDirectory: TargetDirectory, document: string, newDocumentName: string, subDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/rename/{targetDirectory}/{document}/{newDocumentName}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (newDocumentName === undefined || newDocumentName === null)
            throw new Error("The parameter 'newDocumentName' must be defined.");
        url_ = url_.replace("{newDocumentName}", encodeURIComponent("" + newDocumentName));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Rotates pages in the specified document clockwise.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pageNumbers The page numbers (1-based).
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    rotatePagesClockwise(targetDirectory: TargetDirectory, document: string, pageNumbers: number[], subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/rotate-pages-clockwise/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageNumbers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRotatePagesClockwise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRotatePagesClockwise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRotatePagesClockwise(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Rotate pages in the specified document anti clockwise.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pageNumbers The page numbers (1-based).
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    rotatePagesAntiClockwise(targetDirectory: TargetDirectory, document: string, pageNumbers: number[], subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/rotate-pages-anti-clockwise{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageNumbers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRotatePagesAntiClockwise(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRotatePagesAntiClockwise(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRotatePagesAntiClockwise(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes the pages in the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pageNumbers The page numbers (1-based).
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    deletePages(targetDirectory: TargetDirectory, document: string, pageNumbers: number[], subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/delete-pages/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageNumbers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Reorder pages in the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param newPageOrder The new page order.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    reorderPages(targetDirectory: TargetDirectory, document: string, newPageOrder: number[], subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/reorder-pages/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newPageOrder);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorderPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorderPages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReorderPages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Reverse pages order.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    reversePagesOrder(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/reverse-pages-order/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReversePagesOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReversePagesOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReversePagesOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Splits the pages into a new document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param pages The pages.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    splitPages(targetDirectory: TargetDirectory, document: string, pages: number[], subDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/split-pages/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pages);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSplitPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSplitPages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processSplitPages(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Merges another document into the defined document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param mergeDocument The merge document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @param mergeDocumentSubDirectory (optional) Pathname of the merge document sub directory.
     * @return An IActionResult.
     */
    merge(targetDirectory: TargetDirectory, document: string, mergeDocument: string, subDirectory?: string | null | undefined, mergeDocumentSubDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/merge/{targetDirectory}/{document}/{mergeDocument}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (mergeDocument === undefined || mergeDocument === null)
            throw new Error("The parameter 'mergeDocument' must be defined.");
        url_ = url_.replace("{mergeDocument}", encodeURIComponent("" + mergeDocument));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        if (mergeDocumentSubDirectory !== undefined && mergeDocumentSubDirectory !== null)
            url_ += "mergeDocumentSubDirectory=" + encodeURIComponent("" + mergeDocumentSubDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMerge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMerge(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processMerge(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Revert changes to the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    revertChanges(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/revert/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevertChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevertChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRevertChanges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Archives the specified document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    archive(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/archive/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processArchive(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permentently deletes the specified document from the archive.
     * @param document The document.
     * @param subDirectory (optional) 
     * @return An IActionResult.
     */
    deleteFromArchive(document: string, subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/delete/{document}?";
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFromArchive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFromArchive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFromArchive(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Unlocks the document.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param password The password.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    unlock(targetDirectory: TargetDirectory, document: string, password: string, subDirectory?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/unlock/{targetDirectory}/{document}?";
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined.");
        url_ = url_.replace("{targetDirectory}", encodeURIComponent("" + targetDirectory));
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined and cannot be null.");
        else
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Restores a document from the target directory to the inbox.
     * @param targetDirectory The target directory.
     * @param document The document.
     * @param subDirectory (optional) The sub directory containing the document.
     * @return An IActionResult.
     */
    restore(targetDirectory: TargetDirectory, document: string, subDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/restore/{document}?";
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (targetDirectory === undefined || targetDirectory === null)
            throw new Error("The parameter 'targetDirectory' must be defined and cannot be null.");
        else
            url_ += "targetDirectory=" + encodeURIComponent("" + targetDirectory) + "&";
        if (subDirectory !== undefined && subDirectory !== null)
            url_ += "subDirectory=" + encodeURIComponent("" + subDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Saves the specified document from the inbox directory.
     * @param document The document.
     * @param sourceSubDirectory (optional) The subDirectory to move from.
     * @param targetSubDirectory (optional) The subDirectory to save to.
     * @param newName (optional) New name of the file
     * @return An IActionResult.
     */
    saveAs(document: string, sourceSubDirectory?: string | null | undefined, targetSubDirectory?: string | null | undefined, newName?: string | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/save-as/{document}?";
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (sourceSubDirectory !== undefined && sourceSubDirectory !== null)
            url_ += "sourceSubDirectory=" + encodeURIComponent("" + sourceSubDirectory) + "&";
        if (targetSubDirectory !== undefined && targetSubDirectory !== null)
            url_ += "targetSubDirectory=" + encodeURIComponent("" + targetSubDirectory) + "&";
        if (newName === null)
            throw new Error("The parameter 'newName' cannot be null.");
        else if (newName !== undefined)
            url_ += "newName=" + encodeURIComponent("" + newName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processSaveAs(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Saves the specified document from the inbox directory.
     * @param document The document.
     * @param sourceSubDirectory (optional) The subDirectory to move from.
     * @return An IActionResult.
     */
    save(document: string, sourceSubDirectory?: string | null | undefined): Observable<Document | null> {
        let url_ = this.baseUrl + "/api/documents/save/{document}?";
        if (document === undefined || document === null)
            throw new Error("The parameter 'document' must be defined.");
        url_ = url_.replace("{document}", encodeURIComponent("" + document));
        if (sourceSubDirectory !== undefined && sourceSubDirectory !== null)
            url_ += "sourceSubDirectory=" + encodeURIComponent("" + sourceSubDirectory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Document | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Document | null>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<Document | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ProblemDetails.fromJS(resultData500) : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Saves a batch.
     * @param batch The batch.
     * @return An IActionResult.
     */
    saveBatch(batch: Save[]): Observable<DocumentResult[] | null> {
        let url_ = this.baseUrl + "/api/documents/batch/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(batch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentResult[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentResult[] | null>;
        }));
    }

    protected processSaveBatch(response: HttpResponseBase): Observable<DocumentResult[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An IActionResult.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(DocumentResult.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 207) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result207: any = null;
            let resultData207 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData207)) {
                result207 = [] as any;
                for (let item of resultData207)
                    result207!.push(DocumentResult.fromJS(item));
            }
            else {
                result207 = <any>null;
            }
            return _observableOf(result207);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData500)) {
                result500 = [] as any;
                for (let item of resultData500)
                    result500!.push(DocumentResult.fromJS(item));
            }
            else {
                result500 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Saves a batch.
     * @param batch The batch.
     * @return An IActionResult.
     */
    saveAsBatch(batch: SaveAs[]): Observable<DocumentResult[] | null> {
        let url_ = this.baseUrl + "/api/documents/batch/save-as";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(batch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAsBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAsBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentResult[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentResult[] | null>;
        }));
    }

    protected processSaveAsBatch(response: HttpResponseBase): Observable<DocumentResult[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An IActionResult.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(DocumentResult.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 207) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result207: any = null;
            let resultData207 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData207)) {
                result207 = [] as any;
                for (let item of resultData207)
                    result207!.push(DocumentResult.fromJS(item));
            }
            else {
                result207 = <any>null;
            }
            return _observableOf(result207);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData500)) {
                result500 = [] as any;
                for (let item of resultData500)
                    result500!.push(DocumentResult.fromJS(item));
            }
            else {
                result500 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Archive batch.
     * @param batch The batch.
     * @return An IActionResult.
     */
    archiveBatch(batch: Archive[]): Observable<DocumentResult[] | null> {
        let url_ = this.baseUrl + "/api/documents/batch/archive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(batch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchiveBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchiveBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentResult[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentResult[] | null>;
        }));
    }

    protected processArchiveBatch(response: HttpResponseBase): Observable<DocumentResult[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An IActionResult.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(DocumentResult.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 207) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result207: any = null;
            let resultData207 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData207)) {
                result207 = [] as any;
                for (let item of resultData207)
                    result207!.push(DocumentResult.fromJS(item));
            }
            else {
                result207 = <any>null;
            }
            return _observableOf(result207);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData500)) {
                result500 = [] as any;
                for (let item of resultData500)
                    result500!.push(DocumentResult.fromJS(item));
            }
            else {
                result500 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes from archive by batch.
     * @param batch The batch.
     * @return An IActionResult.
     */
    deleteFromArchiveBatch(batch: Delete[]): Observable<DocumentResult[] | null> {
        let url_ = this.baseUrl + "/api/documents/batch/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(batch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFromArchiveBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFromArchiveBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentResult[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentResult[] | null>;
        }));
    }

    protected processDeleteFromArchiveBatch(response: HttpResponseBase): Observable<DocumentResult[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An IActionResult.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(DocumentResult.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 207) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result207: any = null;
            let resultData207 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData207)) {
                result207 = [] as any;
                for (let item of resultData207)
                    result207!.push(DocumentResult.fromJS(item));
            }
            else {
                result207 = <any>null;
            }
            return _observableOf(result207);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData500)) {
                result500 = [] as any;
                for (let item of resultData500)
                    result500!.push(DocumentResult.fromJS(item));
            }
            else {
                result500 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Downloads the document batch.
     * @param batch (optional) The batch.
     * @return An IActionResult.
     */
    downloadDocumentBatch(batch?: Download[] | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/documents/batch/download?";
        if (batch === null)
            throw new Error("The parameter 'batch' cannot be null.");
        else if (batch !== undefined)
            batch && batch.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "batch[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadDocumentBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDocumentBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDownloadDocumentBatch(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An IActionResult.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 207) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result207: any = null;
            let resultData207 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData207)) {
                result207 = [] as any;
                for (let item of resultData207)
                    result207!.push(DocumentResult.fromJS(item));
            }
            else {
                result207 = <any>null;
            }
            return throwException("An IActionResult.", status, _responseText, _headers, result207);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData500)) {
                result500 = [] as any;
                for (let item of resultData500)
                    result500!.push(DocumentResult.fromJS(item));
            }
            else {
                result500 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Restore batch.
     * @param batch The batch.
     * @return An IActionResult.
     */
    restoreBatch(batch: Restore[]): Observable<DocumentResult[] | null> {
        let url_ = this.baseUrl + "/api/documents/batch/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(batch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentResult[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentResult[] | null>;
        }));
    }

    protected processRestoreBatch(response: HttpResponseBase): Observable<DocumentResult[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An IActionResult.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(DocumentResult.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 207) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result207: any = null;
            let resultData207 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData207)) {
                result207 = [] as any;
                for (let item of resultData207)
                    result207!.push(DocumentResult.fromJS(item));
            }
            else {
                result207 = <any>null;
            }
            return _observableOf(result207);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData500)) {
                result500 = [] as any;
                for (let item of resultData500)
                    result500!.push(DocumentResult.fromJS(item));
            }
            else {
                result500 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** A configuration. */
export class Config implements IConfig {
    /** Gets or sets the general configuration. */
    generalConfig!: GeneralConfig;
    /** Gets or sets the header configuration. */
    headerConfig!: HeaderConfig;
    /** Gets or sets the footer configuration. */
    footerConfig!: FooterConfig;
    /** Gets or sets the preview configuration. */
    previewConfig!: PreviewConfig;
    /** Gets or sets the inbox configuration. */
    inboxConfig!: InboxConfig;
    /** Gets or sets the outbox configuration. */
    outboxConfig!: OutboxConfig;
    /** Gets or sets the archive configuration. */
    archiveConfig!: ArchiveConfig;

    constructor(data?: IConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.generalConfig = new GeneralConfig();
            this.headerConfig = new HeaderConfig();
            this.footerConfig = new FooterConfig();
            this.previewConfig = new PreviewConfig();
            this.inboxConfig = new InboxConfig();
            this.outboxConfig = new OutboxConfig();
            this.archiveConfig = new ArchiveConfig();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generalConfig = _data["generalConfig"] ? GeneralConfig.fromJS(_data["generalConfig"]) : new GeneralConfig();
            this.headerConfig = _data["headerConfig"] ? HeaderConfig.fromJS(_data["headerConfig"]) : new HeaderConfig();
            this.footerConfig = _data["footerConfig"] ? FooterConfig.fromJS(_data["footerConfig"]) : new FooterConfig();
            this.previewConfig = _data["previewConfig"] ? PreviewConfig.fromJS(_data["previewConfig"]) : new PreviewConfig();
            this.inboxConfig = _data["inboxConfig"] ? InboxConfig.fromJS(_data["inboxConfig"]) : new InboxConfig();
            this.outboxConfig = _data["outboxConfig"] ? OutboxConfig.fromJS(_data["outboxConfig"]) : new OutboxConfig();
            this.archiveConfig = _data["archiveConfig"] ? ArchiveConfig.fromJS(_data["archiveConfig"]) : new ArchiveConfig();
        }
    }

    static fromJS(data: any): Config {
        data = typeof data === 'object' ? data : {};
        let result = new Config();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generalConfig"] = this.generalConfig ? this.generalConfig.toJSON() : <any>null;
        data["headerConfig"] = this.headerConfig ? this.headerConfig.toJSON() : <any>null;
        data["footerConfig"] = this.footerConfig ? this.footerConfig.toJSON() : <any>null;
        data["previewConfig"] = this.previewConfig ? this.previewConfig.toJSON() : <any>null;
        data["inboxConfig"] = this.inboxConfig ? this.inboxConfig.toJSON() : <any>null;
        data["outboxConfig"] = this.outboxConfig ? this.outboxConfig.toJSON() : <any>null;
        data["archiveConfig"] = this.archiveConfig ? this.archiveConfig.toJSON() : <any>null;
        return data;
    }
}

/** A configuration. */
export interface IConfig {
    /** Gets or sets the general configuration. */
    generalConfig: GeneralConfig;
    /** Gets or sets the header configuration. */
    headerConfig: HeaderConfig;
    /** Gets or sets the footer configuration. */
    footerConfig: FooterConfig;
    /** Gets or sets the preview configuration. */
    previewConfig: PreviewConfig;
    /** Gets or sets the inbox configuration. */
    inboxConfig: InboxConfig;
    /** Gets or sets the outbox configuration. */
    outboxConfig: OutboxConfig;
    /** Gets or sets the archive configuration. */
    archiveConfig: ArchiveConfig;
}

/** A general configuration. */
export class GeneralConfig implements IGeneralConfig {
    /** Gets or sets the default language. */
    defaultLanguage!: string;
    /** Gets or sets a value indicating whether the tour is enabled. */
    enableTour!: boolean;
    /** Gets or sets the default folder. */
    defaultFolder!: string;
    /** Gets or sets the default sort column. */
    defaultSortColumn!: string;
    /** Gets or sets the default sort direction. */
    defaultSortDirection!: string;
    /** Gets or sets a value indicating whether the icons is shown. */
    showIcons!: boolean;
    /** Gets or sets a value indicating whether the labels is shown. */
    showLabels!: boolean;
    /** Gets or sets the default colour mode. */
    defaultColourMode!: string;
    /** Gets or sets a value indicating whether the default show files on save as. */
    defaultShowFilesOnSaveAs!: boolean;
    enableLazyLoading!: boolean;
    lazyLoadingPageSize!: number;
    /** Gets or sets a value indicating whether the debug mode. */
    debugMode!: boolean;

    constructor(data?: IGeneralConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultLanguage = _data["defaultLanguage"] !== undefined ? _data["defaultLanguage"] : <any>null;
            this.enableTour = _data["enableTour"] !== undefined ? _data["enableTour"] : <any>null;
            this.defaultFolder = _data["defaultFolder"] !== undefined ? _data["defaultFolder"] : <any>null;
            this.defaultSortColumn = _data["defaultSortColumn"] !== undefined ? _data["defaultSortColumn"] : <any>null;
            this.defaultSortDirection = _data["defaultSortDirection"] !== undefined ? _data["defaultSortDirection"] : <any>null;
            this.showIcons = _data["showIcons"] !== undefined ? _data["showIcons"] : <any>null;
            this.showLabels = _data["showLabels"] !== undefined ? _data["showLabels"] : <any>null;
            this.defaultColourMode = _data["defaultColourMode"] !== undefined ? _data["defaultColourMode"] : <any>null;
            this.defaultShowFilesOnSaveAs = _data["defaultShowFilesOnSaveAs"] !== undefined ? _data["defaultShowFilesOnSaveAs"] : <any>null;
            this.enableLazyLoading = _data["enableLazyLoading"] !== undefined ? _data["enableLazyLoading"] : <any>null;
            this.lazyLoadingPageSize = _data["lazyLoadingPageSize"] !== undefined ? _data["lazyLoadingPageSize"] : <any>null;
            this.debugMode = _data["debugMode"] !== undefined ? _data["debugMode"] : <any>null;
        }
    }

    static fromJS(data: any): GeneralConfig {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguage"] = this.defaultLanguage !== undefined ? this.defaultLanguage : <any>null;
        data["enableTour"] = this.enableTour !== undefined ? this.enableTour : <any>null;
        data["defaultFolder"] = this.defaultFolder !== undefined ? this.defaultFolder : <any>null;
        data["defaultSortColumn"] = this.defaultSortColumn !== undefined ? this.defaultSortColumn : <any>null;
        data["defaultSortDirection"] = this.defaultSortDirection !== undefined ? this.defaultSortDirection : <any>null;
        data["showIcons"] = this.showIcons !== undefined ? this.showIcons : <any>null;
        data["showLabels"] = this.showLabels !== undefined ? this.showLabels : <any>null;
        data["defaultColourMode"] = this.defaultColourMode !== undefined ? this.defaultColourMode : <any>null;
        data["defaultShowFilesOnSaveAs"] = this.defaultShowFilesOnSaveAs !== undefined ? this.defaultShowFilesOnSaveAs : <any>null;
        data["enableLazyLoading"] = this.enableLazyLoading !== undefined ? this.enableLazyLoading : <any>null;
        data["lazyLoadingPageSize"] = this.lazyLoadingPageSize !== undefined ? this.lazyLoadingPageSize : <any>null;
        data["debugMode"] = this.debugMode !== undefined ? this.debugMode : <any>null;
        return data;
    }
}

/** A general configuration. */
export interface IGeneralConfig {
    /** Gets or sets the default language. */
    defaultLanguage: string;
    /** Gets or sets a value indicating whether the tour is enabled. */
    enableTour: boolean;
    /** Gets or sets the default folder. */
    defaultFolder: string;
    /** Gets or sets the default sort column. */
    defaultSortColumn: string;
    /** Gets or sets the default sort direction. */
    defaultSortDirection: string;
    /** Gets or sets a value indicating whether the icons is shown. */
    showIcons: boolean;
    /** Gets or sets a value indicating whether the labels is shown. */
    showLabels: boolean;
    /** Gets or sets the default colour mode. */
    defaultColourMode: string;
    /** Gets or sets a value indicating whether the default show files on save as. */
    defaultShowFilesOnSaveAs: boolean;
    enableLazyLoading: boolean;
    lazyLoadingPageSize: number;
    /** Gets or sets a value indicating whether the debug mode. */
    debugMode: boolean;
}

/** A header configuration. */
export class HeaderConfig implements IHeaderConfig {
    /** Gets or sets a value indicating whether to make the header sticky. */
    stickyHeader!: boolean;
    /** Gets or sets a value indicating whether the directory picker is shown. */
    showDirectoryPicker!: boolean;
    /** Gets or sets a value indicating whether the search is shown. */
    showSearch!: boolean;
    /** Gets or sets a value indicating whether the preview size picker is shown. */
    showPreviewSizePicker!: boolean;
    /** Gets or sets a value indicating whether the sort picker is shown. */
    showSortPicker!: boolean;
    /** Gets or sets a value indicating whether the colour mode picker is shown. */
    showColourModePicker!: boolean;
    /** Gets or sets a value indicating whether the language picker is shown. */
    showLanguagePicker!: boolean;
    /** Gets or sets a value indicating whether the settings button is shown. */
    showSettingsButton!: boolean;
    /** Gets or sets a value indicating whether the icons is shown. */
    showIcons!: boolean;
    /** Gets or sets a value indicating whether the labels is shown. */
    showLabels!: boolean;

    constructor(data?: IHeaderConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stickyHeader = _data["stickyHeader"] !== undefined ? _data["stickyHeader"] : <any>null;
            this.showDirectoryPicker = _data["showDirectoryPicker"] !== undefined ? _data["showDirectoryPicker"] : <any>null;
            this.showSearch = _data["showSearch"] !== undefined ? _data["showSearch"] : <any>null;
            this.showPreviewSizePicker = _data["showPreviewSizePicker"] !== undefined ? _data["showPreviewSizePicker"] : <any>null;
            this.showSortPicker = _data["showSortPicker"] !== undefined ? _data["showSortPicker"] : <any>null;
            this.showColourModePicker = _data["showColourModePicker"] !== undefined ? _data["showColourModePicker"] : <any>null;
            this.showLanguagePicker = _data["showLanguagePicker"] !== undefined ? _data["showLanguagePicker"] : <any>null;
            this.showSettingsButton = _data["showSettingsButton"] !== undefined ? _data["showSettingsButton"] : <any>null;
            this.showIcons = _data["showIcons"] !== undefined ? _data["showIcons"] : <any>null;
            this.showLabels = _data["showLabels"] !== undefined ? _data["showLabels"] : <any>null;
        }
    }

    static fromJS(data: any): HeaderConfig {
        data = typeof data === 'object' ? data : {};
        let result = new HeaderConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stickyHeader"] = this.stickyHeader !== undefined ? this.stickyHeader : <any>null;
        data["showDirectoryPicker"] = this.showDirectoryPicker !== undefined ? this.showDirectoryPicker : <any>null;
        data["showSearch"] = this.showSearch !== undefined ? this.showSearch : <any>null;
        data["showPreviewSizePicker"] = this.showPreviewSizePicker !== undefined ? this.showPreviewSizePicker : <any>null;
        data["showSortPicker"] = this.showSortPicker !== undefined ? this.showSortPicker : <any>null;
        data["showColourModePicker"] = this.showColourModePicker !== undefined ? this.showColourModePicker : <any>null;
        data["showLanguagePicker"] = this.showLanguagePicker !== undefined ? this.showLanguagePicker : <any>null;
        data["showSettingsButton"] = this.showSettingsButton !== undefined ? this.showSettingsButton : <any>null;
        data["showIcons"] = this.showIcons !== undefined ? this.showIcons : <any>null;
        data["showLabels"] = this.showLabels !== undefined ? this.showLabels : <any>null;
        return data;
    }
}

/** A header configuration. */
export interface IHeaderConfig {
    /** Gets or sets a value indicating whether to make the header sticky. */
    stickyHeader: boolean;
    /** Gets or sets a value indicating whether the directory picker is shown. */
    showDirectoryPicker: boolean;
    /** Gets or sets a value indicating whether the search is shown. */
    showSearch: boolean;
    /** Gets or sets a value indicating whether the preview size picker is shown. */
    showPreviewSizePicker: boolean;
    /** Gets or sets a value indicating whether the sort picker is shown. */
    showSortPicker: boolean;
    /** Gets or sets a value indicating whether the colour mode picker is shown. */
    showColourModePicker: boolean;
    /** Gets or sets a value indicating whether the language picker is shown. */
    showLanguagePicker: boolean;
    /** Gets or sets a value indicating whether the settings button is shown. */
    showSettingsButton: boolean;
    /** Gets or sets a value indicating whether the icons is shown. */
    showIcons: boolean;
    /** Gets or sets a value indicating whether the labels is shown. */
    showLabels: boolean;
}

/** A footer configuration. */
export class FooterConfig implements IFooterConfig {
    /** Gets or sets a value indicating whether the always is shown. */
    showAlways!: boolean;
    /** Gets or sets a value indicating whether the select all is shown. */
    showSelectAll!: boolean;
    /** Gets or sets a value indicating whether the deselect all is shown. */
    showDeselectAll!: boolean;

    constructor(data?: IFooterConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showAlways = _data["showAlways"] !== undefined ? _data["showAlways"] : <any>null;
            this.showSelectAll = _data["showSelectAll"] !== undefined ? _data["showSelectAll"] : <any>null;
            this.showDeselectAll = _data["showDeselectAll"] !== undefined ? _data["showDeselectAll"] : <any>null;
        }
    }

    static fromJS(data: any): FooterConfig {
        data = typeof data === 'object' ? data : {};
        let result = new FooterConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showAlways"] = this.showAlways !== undefined ? this.showAlways : <any>null;
        data["showSelectAll"] = this.showSelectAll !== undefined ? this.showSelectAll : <any>null;
        data["showDeselectAll"] = this.showDeselectAll !== undefined ? this.showDeselectAll : <any>null;
        return data;
    }
}

/** A footer configuration. */
export interface IFooterConfig {
    /** Gets or sets a value indicating whether the always is shown. */
    showAlways: boolean;
    /** Gets or sets a value indicating whether the select all is shown. */
    showSelectAll: boolean;
    /** Gets or sets a value indicating whether the deselect all is shown. */
    showDeselectAll: boolean;
}

/** A preview configuration. */
export class PreviewConfig implements IPreviewConfig {
    /** Gets or sets the default size. */
    defaultSize!: string;
    /** Gets or sets a value indicating whether the page number is shown. */
    showPageNumber!: boolean;
    /** Gets or sets a value indicating whether to blur the image. */
    blur!: boolean;

    constructor(data?: IPreviewConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultSize = _data["defaultSize"] !== undefined ? _data["defaultSize"] : <any>null;
            this.showPageNumber = _data["showPageNumber"] !== undefined ? _data["showPageNumber"] : <any>null;
            this.blur = _data["blur"] !== undefined ? _data["blur"] : <any>null;
        }
    }

    static fromJS(data: any): PreviewConfig {
        data = typeof data === 'object' ? data : {};
        let result = new PreviewConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultSize"] = this.defaultSize !== undefined ? this.defaultSize : <any>null;
        data["showPageNumber"] = this.showPageNumber !== undefined ? this.showPageNumber : <any>null;
        data["blur"] = this.blur !== undefined ? this.blur : <any>null;
        return data;
    }
}

/** A preview configuration. */
export interface IPreviewConfig {
    /** Gets or sets the default size. */
    defaultSize: string;
    /** Gets or sets a value indicating whether the page number is shown. */
    showPageNumber: boolean;
    /** Gets or sets a value indicating whether to blur the image. */
    blur: boolean;
}

/** A inbox configuration. */
export class InboxConfig implements IInboxConfig {
    /** Gets or sets a value indicating whether the save as is shown. */
    showSaveAs!: boolean;
    /** Gets or sets a value indicating whether the save is shown. */
    showSave!: boolean;
    /** Gets or sets a value indicating whether the revert is shown. */
    showRevert!: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload!: boolean;
    /** Gets or sets a value indicating whether the archive is shown. */
    showArchive!: boolean;
    /** Gets or sets a value indicating whether the rename is shown. */
    showRename!: boolean;
    /** Gets or sets a value indicating whether the reverse page order is shown. */
    showReversePageOrder!: boolean;
    /** Gets or sets a value indicating whether the merge is shown. */
    showMerge!: boolean;
    /** Gets or sets a value indicating whether the split is shown. */
    showSplit!: boolean;
    /** Gets or sets a value indicating whether the remove is shown. */
    showRemove!: boolean;
    /** Gets or sets a value indicating whether the rotate clockwise is shown. */
    showRotateClockwise!: boolean;
    /** Gets or sets a value indicating whether the rotate anti clockwise is shown. */
    showRotateAntiClockwise!: boolean;
    /** Gets or sets a value indicating whether the select all is shown. */
    showSelectAll!: boolean;
    /** Gets or sets a value indicating whether the unselect is shown. */
    showUnselect!: boolean;
    /** Gets or sets a value indicating whether the batch show archive. */
    batchShowArchive!: boolean;
    /** Gets or sets a value indicating whether the batch show download. */
    batchShowDownload!: boolean;
    /** Gets or sets a value indicating whether the batch show save as. */
    batchShowSaveAs!: boolean;
    /** Gets or sets a value indicating whether the batch show save. */
    batchShowSave!: boolean;
    /** Gets or sets a value indicating whether to archive the original file on save . */
    archiveOriginalFileOnSave!: boolean;
    /** Gets or sets a value indicating whether to archive a file on merging it with another. */
    archiveFileOnMerge!: boolean;
    /** Gets or sets a value indicating whether the document on archive wil be deleted. */
    deleteDocumentOnArchive!: boolean;

    constructor(data?: IInboxConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showSaveAs = _data["showSaveAs"] !== undefined ? _data["showSaveAs"] : <any>null;
            this.showSave = _data["showSave"] !== undefined ? _data["showSave"] : <any>null;
            this.showRevert = _data["showRevert"] !== undefined ? _data["showRevert"] : <any>null;
            this.showDownload = _data["showDownload"] !== undefined ? _data["showDownload"] : <any>null;
            this.showArchive = _data["showArchive"] !== undefined ? _data["showArchive"] : <any>null;
            this.showRename = _data["showRename"] !== undefined ? _data["showRename"] : <any>null;
            this.showReversePageOrder = _data["showReversePageOrder"] !== undefined ? _data["showReversePageOrder"] : <any>null;
            this.showMerge = _data["showMerge"] !== undefined ? _data["showMerge"] : <any>null;
            this.showSplit = _data["showSplit"] !== undefined ? _data["showSplit"] : <any>null;
            this.showRemove = _data["showRemove"] !== undefined ? _data["showRemove"] : <any>null;
            this.showRotateClockwise = _data["showRotateClockwise"] !== undefined ? _data["showRotateClockwise"] : <any>null;
            this.showRotateAntiClockwise = _data["showRotateAntiClockwise"] !== undefined ? _data["showRotateAntiClockwise"] : <any>null;
            this.showSelectAll = _data["showSelectAll"] !== undefined ? _data["showSelectAll"] : <any>null;
            this.showUnselect = _data["showUnselect"] !== undefined ? _data["showUnselect"] : <any>null;
            this.batchShowArchive = _data["batchShowArchive"] !== undefined ? _data["batchShowArchive"] : <any>null;
            this.batchShowDownload = _data["batchShowDownload"] !== undefined ? _data["batchShowDownload"] : <any>null;
            this.batchShowSaveAs = _data["batchShowSaveAs"] !== undefined ? _data["batchShowSaveAs"] : <any>null;
            this.batchShowSave = _data["batchShowSave"] !== undefined ? _data["batchShowSave"] : <any>null;
            this.archiveOriginalFileOnSave = _data["archiveOriginalFileOnSave"] !== undefined ? _data["archiveOriginalFileOnSave"] : <any>null;
            this.archiveFileOnMerge = _data["archiveFileOnMerge"] !== undefined ? _data["archiveFileOnMerge"] : <any>null;
            this.deleteDocumentOnArchive = _data["deleteDocumentOnArchive"] !== undefined ? _data["deleteDocumentOnArchive"] : <any>null;
        }
    }

    static fromJS(data: any): InboxConfig {
        data = typeof data === 'object' ? data : {};
        let result = new InboxConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showSaveAs"] = this.showSaveAs !== undefined ? this.showSaveAs : <any>null;
        data["showSave"] = this.showSave !== undefined ? this.showSave : <any>null;
        data["showRevert"] = this.showRevert !== undefined ? this.showRevert : <any>null;
        data["showDownload"] = this.showDownload !== undefined ? this.showDownload : <any>null;
        data["showArchive"] = this.showArchive !== undefined ? this.showArchive : <any>null;
        data["showRename"] = this.showRename !== undefined ? this.showRename : <any>null;
        data["showReversePageOrder"] = this.showReversePageOrder !== undefined ? this.showReversePageOrder : <any>null;
        data["showMerge"] = this.showMerge !== undefined ? this.showMerge : <any>null;
        data["showSplit"] = this.showSplit !== undefined ? this.showSplit : <any>null;
        data["showRemove"] = this.showRemove !== undefined ? this.showRemove : <any>null;
        data["showRotateClockwise"] = this.showRotateClockwise !== undefined ? this.showRotateClockwise : <any>null;
        data["showRotateAntiClockwise"] = this.showRotateAntiClockwise !== undefined ? this.showRotateAntiClockwise : <any>null;
        data["showSelectAll"] = this.showSelectAll !== undefined ? this.showSelectAll : <any>null;
        data["showUnselect"] = this.showUnselect !== undefined ? this.showUnselect : <any>null;
        data["batchShowArchive"] = this.batchShowArchive !== undefined ? this.batchShowArchive : <any>null;
        data["batchShowDownload"] = this.batchShowDownload !== undefined ? this.batchShowDownload : <any>null;
        data["batchShowSaveAs"] = this.batchShowSaveAs !== undefined ? this.batchShowSaveAs : <any>null;
        data["batchShowSave"] = this.batchShowSave !== undefined ? this.batchShowSave : <any>null;
        data["archiveOriginalFileOnSave"] = this.archiveOriginalFileOnSave !== undefined ? this.archiveOriginalFileOnSave : <any>null;
        data["archiveFileOnMerge"] = this.archiveFileOnMerge !== undefined ? this.archiveFileOnMerge : <any>null;
        data["deleteDocumentOnArchive"] = this.deleteDocumentOnArchive !== undefined ? this.deleteDocumentOnArchive : <any>null;
        return data;
    }
}

/** A inbox configuration. */
export interface IInboxConfig {
    /** Gets or sets a value indicating whether the save as is shown. */
    showSaveAs: boolean;
    /** Gets or sets a value indicating whether the save is shown. */
    showSave: boolean;
    /** Gets or sets a value indicating whether the revert is shown. */
    showRevert: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload: boolean;
    /** Gets or sets a value indicating whether the archive is shown. */
    showArchive: boolean;
    /** Gets or sets a value indicating whether the rename is shown. */
    showRename: boolean;
    /** Gets or sets a value indicating whether the reverse page order is shown. */
    showReversePageOrder: boolean;
    /** Gets or sets a value indicating whether the merge is shown. */
    showMerge: boolean;
    /** Gets or sets a value indicating whether the split is shown. */
    showSplit: boolean;
    /** Gets or sets a value indicating whether the remove is shown. */
    showRemove: boolean;
    /** Gets or sets a value indicating whether the rotate clockwise is shown. */
    showRotateClockwise: boolean;
    /** Gets or sets a value indicating whether the rotate anti clockwise is shown. */
    showRotateAntiClockwise: boolean;
    /** Gets or sets a value indicating whether the select all is shown. */
    showSelectAll: boolean;
    /** Gets or sets a value indicating whether the unselect is shown. */
    showUnselect: boolean;
    /** Gets or sets a value indicating whether the batch show archive. */
    batchShowArchive: boolean;
    /** Gets or sets a value indicating whether the batch show download. */
    batchShowDownload: boolean;
    /** Gets or sets a value indicating whether the batch show save as. */
    batchShowSaveAs: boolean;
    /** Gets or sets a value indicating whether the batch show save. */
    batchShowSave: boolean;
    /** Gets or sets a value indicating whether to archive the original file on save . */
    archiveOriginalFileOnSave: boolean;
    /** Gets or sets a value indicating whether to archive a file on merging it with another. */
    archiveFileOnMerge: boolean;
    /** Gets or sets a value indicating whether the document on archive wil be deleted. */
    deleteDocumentOnArchive: boolean;
}

/** A outbox configuration. */
export class OutboxConfig implements IOutboxConfig {
    /** Gets or sets a value indicating whether the restore is shown. */
    showRestore!: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload!: boolean;
    /** Gets or sets a value indicating whether the batch show restore. */
    batchShowRestore!: boolean;
    /** Gets or sets a value indicating whether the batch show download. */
    batchShowDownload!: boolean;

    constructor(data?: IOutboxConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showRestore = _data["showRestore"] !== undefined ? _data["showRestore"] : <any>null;
            this.showDownload = _data["showDownload"] !== undefined ? _data["showDownload"] : <any>null;
            this.batchShowRestore = _data["batchShowRestore"] !== undefined ? _data["batchShowRestore"] : <any>null;
            this.batchShowDownload = _data["batchShowDownload"] !== undefined ? _data["batchShowDownload"] : <any>null;
        }
    }

    static fromJS(data: any): OutboxConfig {
        data = typeof data === 'object' ? data : {};
        let result = new OutboxConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showRestore"] = this.showRestore !== undefined ? this.showRestore : <any>null;
        data["showDownload"] = this.showDownload !== undefined ? this.showDownload : <any>null;
        data["batchShowRestore"] = this.batchShowRestore !== undefined ? this.batchShowRestore : <any>null;
        data["batchShowDownload"] = this.batchShowDownload !== undefined ? this.batchShowDownload : <any>null;
        return data;
    }
}

/** A outbox configuration. */
export interface IOutboxConfig {
    /** Gets or sets a value indicating whether the restore is shown. */
    showRestore: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload: boolean;
    /** Gets or sets a value indicating whether the batch show restore. */
    batchShowRestore: boolean;
    /** Gets or sets a value indicating whether the batch show download. */
    batchShowDownload: boolean;
}

/** A archive configuration. */
export class ArchiveConfig implements IArchiveConfig {
    /** Gets or sets a value indicating whether the restore is shown. */
    showRestore!: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload!: boolean;
    /** Gets or sets a value indicating whether the delete is shown. */
    showDelete!: boolean;
    /** Gets or sets a value indicating whether the batch show restore. */
    batchShowRestore!: boolean;
    /** Gets or sets a value indicating whether the batch show download. */
    batchShowDownload!: boolean;
    /** Gets or sets a value indicating whether the batch show delete. */
    batchShowDelete!: boolean;

    constructor(data?: IArchiveConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showRestore = _data["showRestore"] !== undefined ? _data["showRestore"] : <any>null;
            this.showDownload = _data["showDownload"] !== undefined ? _data["showDownload"] : <any>null;
            this.showDelete = _data["showDelete"] !== undefined ? _data["showDelete"] : <any>null;
            this.batchShowRestore = _data["batchShowRestore"] !== undefined ? _data["batchShowRestore"] : <any>null;
            this.batchShowDownload = _data["batchShowDownload"] !== undefined ? _data["batchShowDownload"] : <any>null;
            this.batchShowDelete = _data["batchShowDelete"] !== undefined ? _data["batchShowDelete"] : <any>null;
        }
    }

    static fromJS(data: any): ArchiveConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ArchiveConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showRestore"] = this.showRestore !== undefined ? this.showRestore : <any>null;
        data["showDownload"] = this.showDownload !== undefined ? this.showDownload : <any>null;
        data["showDelete"] = this.showDelete !== undefined ? this.showDelete : <any>null;
        data["batchShowRestore"] = this.batchShowRestore !== undefined ? this.batchShowRestore : <any>null;
        data["batchShowDownload"] = this.batchShowDownload !== undefined ? this.batchShowDownload : <any>null;
        data["batchShowDelete"] = this.batchShowDelete !== undefined ? this.batchShowDelete : <any>null;
        return data;
    }
}

/** A archive configuration. */
export interface IArchiveConfig {
    /** Gets or sets a value indicating whether the restore is shown. */
    showRestore: boolean;
    /** Gets or sets a value indicating whether the download is shown. */
    showDownload: boolean;
    /** Gets or sets a value indicating whether the delete is shown. */
    showDelete: boolean;
    /** Gets or sets a value indicating whether the batch show restore. */
    batchShowRestore: boolean;
    /** Gets or sets a value indicating whether the batch show download. */
    batchShowDownload: boolean;
    /** Gets or sets a value indicating whether the batch show delete. */
    batchShowDelete: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    extensions!: { [key: string]: any; };

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.extensions = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key] !== undefined ? _data["extensions"][key] : <any>null;
                }
            }
            else {
                this.extensions = <any>null;
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key] !== undefined ? this.extensions[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    extensions: { [key: string]: any; };

    [key: string]: any;
}

/** A folder. */
export class Folder implements IFolder {
    /** Gets or sets the name. */
    name!: string;
    /** Gets or sets the sub folders. */
    subFolders!: Folder[];
    /** Gets or sets the documents. */
    documents!: Document[];

    constructor(data?: IFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.subFolders = [];
            this.documents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["subFolders"])) {
                this.subFolders = [] as any;
                for (let item of _data["subFolders"])
                    this.subFolders!.push(Folder.fromJS(item));
            }
            else {
                this.subFolders = <any>null;
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(Document.fromJS(item));
            }
            else {
                this.documents = <any>null;
            }
        }
    }

    static fromJS(data: any): Folder {
        data = typeof data === 'object' ? data : {};
        let result = new Folder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.subFolders)) {
            data["subFolders"] = [];
            for (let item of this.subFolders)
                data["subFolders"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        return data;
    }
}

/** A folder. */
export interface IFolder {
    /** Gets or sets the name. */
    name: string;
    /** Gets or sets the sub folders. */
    subFolders: Folder[];
    /** Gets or sets the documents. */
    documents: Document[];
}

/** A document. */
export class Document implements IDocument {
    /** Gets or sets the name. */
    name!: string;
    /** Gets or sets the pathname of the directory. */
    directory!: string;
    /** Gets or sets the Date/Time of the created. */
    created!: Date;
    /** Gets or sets the Date/Time of the last modified. */
    lastModified!: Date;
    /** Gets or sets a value indicating whether this object has changes. */
    hasChanges!: boolean;
    /** Gets or sets the document status. */
    status!: DocumentStatus;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.directory = _data["directory"] !== undefined ? _data["directory"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.hasChanges = _data["hasChanges"] !== undefined ? _data["hasChanges"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["directory"] = this.directory !== undefined ? this.directory : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["hasChanges"] = this.hasChanges !== undefined ? this.hasChanges : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        return data;
    }
}

/** A document. */
export interface IDocument {
    /** Gets or sets the name. */
    name: string;
    /** Gets or sets the pathname of the directory. */
    directory: string;
    /** Gets or sets the Date/Time of the created. */
    created: Date;
    /** Gets or sets the Date/Time of the last modified. */
    lastModified: Date;
    /** Gets or sets a value indicating whether this object has changes. */
    hasChanges: boolean;
    /** Gets or sets the document status. */
    status: DocumentStatus;
}

/** Values that represent document status. 0 = Ok 1 = Corrupted 2 = PasswordProtected */
export enum DocumentStatus {
    Ok = 0,
    Corrupted = 1,
    PasswordProtected = 2,
}

/** Values that represent target directories. 0 = Inbox 1 = Outbox 2 = Archive */
export enum TargetDirectory {
    Inbox = 0,
    Outbox = 1,
    Archive = 2,
}

export class FileUploadModel implements IFileUploadModel {
    file!: any;

    constructor(data?: IFileUploadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"] !== undefined ? _data["file"] : <any>null;
        }
    }

    static fromJS(data: any): FileUploadModel {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file !== undefined ? this.file : <any>null;
        return data;
    }
}

export interface IFileUploadModel {
    file: any;
}

/** Encapsulates the result of a document. */
export class DocumentResult implements IDocumentResult {
    /** Gets or sets the document. */
    document!: string;
    /** Gets or sets the status code. */
    statusCode!: number;
    /** Gets or sets information describing the additional. */
    additionalInformation?: string | null;

    constructor(data?: IDocumentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.statusCode = _data["statusCode"] !== undefined ? _data["statusCode"] : <any>null;
            this.additionalInformation = _data["additionalInformation"] !== undefined ? _data["additionalInformation"] : <any>null;
        }
    }

    static fromJS(data: any): DocumentResult {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["statusCode"] = this.statusCode !== undefined ? this.statusCode : <any>null;
        data["additionalInformation"] = this.additionalInformation !== undefined ? this.additionalInformation : <any>null;
        return data;
    }
}

/** Encapsulates the result of a document. */
export interface IDocumentResult {
    /** Gets or sets the document. */
    document: string;
    /** Gets or sets the status code. */
    statusCode: number;
    /** Gets or sets information describing the additional. */
    additionalInformation?: string | null;
}

/** A save. */
export class Save implements ISave {
    /** Gets or sets the document. */
    document!: string;
    /** Gets or sets the pathname of the source sub directory. */
    sourceSubDirectory?: string | null;

    constructor(data?: ISave) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.sourceSubDirectory = _data["sourceSubDirectory"] !== undefined ? _data["sourceSubDirectory"] : <any>null;
        }
    }

    static fromJS(data: any): Save {
        data = typeof data === 'object' ? data : {};
        let result = new Save();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["sourceSubDirectory"] = this.sourceSubDirectory !== undefined ? this.sourceSubDirectory : <any>null;
        return data;
    }
}

/** A save. */
export interface ISave {
    /** Gets or sets the document. */
    document: string;
    /** Gets or sets the pathname of the source sub directory. */
    sourceSubDirectory?: string | null;
}

/** A save as. */
export class SaveAs implements ISaveAs {
    /** Gets or sets the document. */
    document!: string;
    /** Gets or sets the pathname of the source sub directory. */
    sourceSubDirectory?: string | null;
    /** Gets or sets the pathname of the target sub directory. */
    targetSubDirectory?: string | null;
    /** Gets or sets the name of the new. */
    newName?: string | null;

    constructor(data?: ISaveAs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.sourceSubDirectory = _data["sourceSubDirectory"] !== undefined ? _data["sourceSubDirectory"] : <any>null;
            this.targetSubDirectory = _data["targetSubDirectory"] !== undefined ? _data["targetSubDirectory"] : <any>null;
            this.newName = _data["newName"] !== undefined ? _data["newName"] : <any>null;
        }
    }

    static fromJS(data: any): SaveAs {
        data = typeof data === 'object' ? data : {};
        let result = new SaveAs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["sourceSubDirectory"] = this.sourceSubDirectory !== undefined ? this.sourceSubDirectory : <any>null;
        data["targetSubDirectory"] = this.targetSubDirectory !== undefined ? this.targetSubDirectory : <any>null;
        data["newName"] = this.newName !== undefined ? this.newName : <any>null;
        return data;
    }
}

/** A save as. */
export interface ISaveAs {
    /** Gets or sets the document. */
    document: string;
    /** Gets or sets the pathname of the source sub directory. */
    sourceSubDirectory?: string | null;
    /** Gets or sets the pathname of the target sub directory. */
    targetSubDirectory?: string | null;
    /** Gets or sets the name of the new. */
    newName?: string | null;
}

/** An archive. */
export class Archive implements IArchive {
    /** Gets or sets the pathname of the target directory. */
    targetDirectory!: TargetDirectory;
    /** Gets or sets the document. */
    document!: string;
    /** Gets or sets the pathname of the source sub directory. */
    subDirectory?: string | null;

    constructor(data?: IArchive) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetDirectory = _data["targetDirectory"] !== undefined ? _data["targetDirectory"] : <any>null;
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.subDirectory = _data["subDirectory"] !== undefined ? _data["subDirectory"] : <any>null;
        }
    }

    static fromJS(data: any): Archive {
        data = typeof data === 'object' ? data : {};
        let result = new Archive();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetDirectory"] = this.targetDirectory !== undefined ? this.targetDirectory : <any>null;
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["subDirectory"] = this.subDirectory !== undefined ? this.subDirectory : <any>null;
        return data;
    }
}

/** An archive. */
export interface IArchive {
    /** Gets or sets the pathname of the target directory. */
    targetDirectory: TargetDirectory;
    /** Gets or sets the document. */
    document: string;
    /** Gets or sets the pathname of the source sub directory. */
    subDirectory?: string | null;
}

/** A delete. */
export class Delete implements IDelete {
    /** Gets or sets the document. */
    document!: string;
    /** Gets or sets the pathname of the source sub directory. */
    subDirectory?: string | null;

    constructor(data?: IDelete) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.subDirectory = _data["subDirectory"] !== undefined ? _data["subDirectory"] : <any>null;
        }
    }

    static fromJS(data: any): Delete {
        data = typeof data === 'object' ? data : {};
        let result = new Delete();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["subDirectory"] = this.subDirectory !== undefined ? this.subDirectory : <any>null;
        return data;
    }
}

/** A delete. */
export interface IDelete {
    /** Gets or sets the document. */
    document: string;
    /** Gets or sets the pathname of the source sub directory. */
    subDirectory?: string | null;
}

/** A download. */
export class Download implements IDownload {
    /** Gets or sets the pathname of the target directory. */
    targetDirectory!: TargetDirectory;
    /** Gets or sets the document. */
    document!: string;
    /** Gets or sets the pathname of the source sub directory. */
    subDirectory?: string | null;

    constructor(data?: IDownload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetDirectory = _data["targetDirectory"] !== undefined ? _data["targetDirectory"] : <any>null;
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.subDirectory = _data["subDirectory"] !== undefined ? _data["subDirectory"] : <any>null;
        }
    }

    static fromJS(data: any): Download {
        data = typeof data === 'object' ? data : {};
        let result = new Download();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetDirectory"] = this.targetDirectory !== undefined ? this.targetDirectory : <any>null;
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["subDirectory"] = this.subDirectory !== undefined ? this.subDirectory : <any>null;
        return data;
    }
}

/** A download. */
export interface IDownload {
    /** Gets or sets the pathname of the target directory. */
    targetDirectory: TargetDirectory;
    /** Gets or sets the document. */
    document: string;
    /** Gets or sets the pathname of the source sub directory. */
    subDirectory?: string | null;
}

/** An restore. */
export class Restore implements IRestore {
    /** Gets or sets the pathname of the target directory. */
    targetDirectory!: TargetDirectory;
    /** Gets or sets the document. */
    document!: string;
    /** Gets or sets the pathname of the source sub directory. */
    subDirectory?: string | null;

    constructor(data?: IRestore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetDirectory = _data["targetDirectory"] !== undefined ? _data["targetDirectory"] : <any>null;
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.subDirectory = _data["subDirectory"] !== undefined ? _data["subDirectory"] : <any>null;
        }
    }

    static fromJS(data: any): Restore {
        data = typeof data === 'object' ? data : {};
        let result = new Restore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetDirectory"] = this.targetDirectory !== undefined ? this.targetDirectory : <any>null;
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["subDirectory"] = this.subDirectory !== undefined ? this.subDirectory : <any>null;
        return data;
    }
}

/** An restore. */
export interface IRestore {
    /** Gets or sets the pathname of the target directory. */
    targetDirectory: TargetDirectory;
    /** Gets or sets the document. */
    document: string;
    /** Gets or sets the pathname of the source sub directory. */
    subDirectory?: string | null;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

}